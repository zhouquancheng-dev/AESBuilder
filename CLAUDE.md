# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

AESBuilder is a template-driven code generation tool that produces hardened AES-128 encryption SO libraries for Android. A single `config.json` drives a Python script (`build_so.py`) that renders templates, invokes Gradle/CMake, and collects build artifacts.

## Build Commands

```bash
# Full pipeline: generate files from templates + build SO + collect output
python build_so.py

# Build only the native library (after templates are already generated)
./gradlew :lib_module:assembleRelease

# Build the test app (depends on lib_module source)
./gradlew :app:assembleDebug
```

## Architecture

### Generation Pipeline

```
config.json → build_so.py → templates/*.tmpl → generated source files → Gradle/CMake build → output/
```

**4-stage pipeline in `build_so.py`:**
1. Load & validate `config.json`
2. Render 5 template files into `lib_module/` and its source directories
3. Execute `./gradlew :lib_module:assembleRelease`
4. Copy SO files + Java JNI class to `output/`

### Module Structure

- **app/** — Test app module (Kotlin). Depends on `:lib_module` directly. Used to verify encryption/decryption and obtain APK signature hash via `SignatureUtil`.
- **lib_module/** — Android Library with CMake native build. Contains C source for AES, Base64, signature checking, anti-debug, and emulator detection. Some files are static (`aes.c`, `base64.c`, `debugger.c`, `check_emulator.c`), others are generated from templates (`JNIEncrypt.c`, `checksignature.h`, `CMakeLists.txt`, `build.gradle.kts`, JNI Java class).
- **templates/** — `.tmpl` files with `{{PLACEHOLDER}}` syntax, processed by simple string replacement in `build_so.py:render_template()`.

### Generated vs Static Files in lib_module

**Generated by build_so.py (from templates):**
- `lib_module/src/main/cpp/JNIEncrypt.c` — JNI bindings, key storage, encode/decode
- `lib_module/src/main/cpp/checksignature.h` — package name + signature hash constants
- `lib_module/CMakeLists.txt` — SO library name
- `lib_module/build.gradle.kts` — ABI filters
- `lib_module/src/main/java/.../JniEncrypt.java` — Java native method declarations

**Static (not generated):**
- `aes.c/h` — AES-128 ECB implementation
- `base64.c/h` — Base64 encoding/decoding
- `checksignature.c` — Signature verification logic via JNI reflection
- `check_emulator.c/h` — Emulator detection
- `debugger.c/h` — Anti-debug (ptrace)
- `logger.h` — Logging macros

### Key Obfuscation

`build_so.py:generate_key_code()` transforms the AES key: Base64 encode → prepend interference char → generate per-character C assignment code (`s[n++] = 'X';`). This prevents the key from appearing as a plain string in the binary.

## Build Environment

- Python 3.6+, JDK 17 or 21, Android SDK with NDK and CMake
- Gradle 8.11.2, AGP 8.x, Kotlin 2.2.0
- compileSdk 35, minSdk 26, targetSdk 35

## Key Conventions

- All customization goes through `config.json` — never edit generated files directly
- Template placeholders use `{{DOUBLE_BRACE}}` format
- The `output/` directory is ephemeral (cleared on each build)
- Native methods verify APK signature before performing encryption; failed checks return `"UNSIGNATURE"`
- Signature check returns: 1 (pass), -1 (package mismatch), -2 (signature hash mismatch)
